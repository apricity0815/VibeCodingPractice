
import { GoogleGenAI } from "@google/genai";
import { SYSTEM_INSTRUCTIONS } from "../constants";

export class GeminiService {
  private ai: GoogleGenAI;

  constructor() {
    this.ai = new GoogleGenAI({ apiKey: process.env.API_KEY || '' });
  }

  /**
   * Generates an initial mockup based on a logo and a product description.
   */
  async generateMockup(logoBase64: string, productPrompt: string): Promise<string> {
    const model = 'gemini-2.5-flash-image';
    
    // Remove data URL prefix if present
    const cleanLogo = logoBase64.replace(/^data:image\/(png|jpeg|webp);base64,/, '');

    const response = await this.ai.models.generateContent({
      model,
      contents: {
        parts: [
          {
            inlineData: {
              data: cleanLogo,
              mimeType: 'image/png'
            }
          },
          {
            text: `Place this logo realistically on the product in the following scene: ${productPrompt}. Ensure the lighting matches and the logo appears printed or embroidered naturally.`
          }
        ]
      },
      config: {
        systemInstruction: SYSTEM_INSTRUCTIONS
      }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }

    throw new Error('No image was generated by the model.');
  }

  /**
   * Edits an existing mockup using a natural language prompt.
   */
  async editMockup(currentImageBase64: string, editPrompt: string, originalLogoBase64?: string): Promise<string> {
    const model = 'gemini-2.5-flash-image';
    
    const cleanImage = currentImageBase64.replace(/^data:image\/(png|jpeg|webp);base64,/, '');
    
    const parts: any[] = [
      {
        inlineData: {
          data: cleanImage,
          mimeType: 'image/png'
        }
      }
    ];

    if (originalLogoBase64) {
      const cleanLogo = originalLogoBase64.replace(/^data:image\/(png|jpeg|webp);base64,/, '');
      parts.push({
        inlineData: {
          data: cleanLogo,
          mimeType: 'image/png'
        }
      });
      parts.push({
        text: `Using the provided logo as reference for any placement needed, modify the current mockup image according to this instruction: ${editPrompt}. Maintain the integrity of the logo placement.`
      });
    } else {
      parts.push({
        text: `Modify the current mockup image according to this instruction: ${editPrompt}.`
      });
    }

    const response = await this.ai.models.generateContent({
      model,
      contents: { parts },
      config: {
        systemInstruction: SYSTEM_INSTRUCTIONS
      }
    });

    for (const part of response.candidates?.[0]?.content?.parts || []) {
      if (part.inlineData) {
        return `data:image/png;base64,${part.inlineData.data}`;
      }
    }

    throw new Error('Could not edit the image. The model returned no image data.');
  }
}

export const geminiService = new GeminiService();
